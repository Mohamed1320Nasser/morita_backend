generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  admin
  system
  tester
  user
}

enum DiscordRole {
  admin
  support
  worker
  customer
}

enum OtpType {
  verify_email
  forget_email
}

model User {
  id                  Int       @id @default(autoincrement()) @db.UnsignedInt
  fullname            String
  username            String?   @unique
  email               String    @unique
  phone               String?
  password            String?
  profileId           Int?      @unique @db.UnsignedInt
  emailIsVerified     Boolean   @default(false)
  emailVerifyToken    String?
  passwordSetupToken  String?   @unique
  passwordSetupExpiry DateTime? @db.DateTime(0)
  banned              Boolean   @default(false)
  role                Role      @default(user)
  createdAt           DateTime  @default(now()) @db.DateTime(0)
  updatedAt           DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt           DateTime?

  // Discord integration
  discordId           String?       @unique // Discord user ID
  discordRole         DiscordRole?  @default(customer) // Discord server role

  sessions     Session[]
  otpRequests  OtpRequest[]
  files        File[]        @relation("fileUploader")
  profile      File?         @relation("userProfile", fields: [profileId], references: [id])

  // Order relations
  customerOrders    Order[]       @relation("customerOrders")
  workerOrders      Order[]       @relation("workerOrders")
  supportOrders     Order[]       @relation("supportOrders")
  statusChangeHistory OrderStatusHistory[] @relation("statusChangeHistory")

  transactions Transaction[] @relation("userTransactions")
  wallet       Wallet?       @relation("userWallet")
  walletTransactionsCreated WalletTransaction[] @relation("transactionCreator")

  // Ticket relations
  customerTickets    Ticket[]        @relation("customerTickets")
  supportTickets     Ticket[]        @relation("supportTickets")
  ticketMessages     TicketMessage[] @relation("ticketMessageAuthor")

  @@index([email])
  @@index([role])
  @@index([discordId])
  @@index([discordRole])
}

model Session {
  id            Int       @id @default(autoincrement()) @db.UnsignedInt
  token         String    @unique
  identifier    String
  userId        Int       @db.UnsignedInt
  tenantId      String?
  companyId     Int?      @db.UnsignedInt
  source        String?
  langCode      String?
  expired       Boolean   @default(false)
  expired_since DateTime? @db.DateTime(0)
  createdAt     DateTime  @default(now()) @db.DateTime(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tenantId])
  @@index([companyId])
}

model OtpRequest {
  id        String   @id @default(uuid())
  userId    Int?     @db.UnsignedInt
  email     String?
  otp       String
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  expiredAt DateTime @default(now()) @db.DateTime(0)
  createdAt DateTime @default(now()) @db.DateTime(0)
  type      OtpType

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
}

model File {
  id         Int      @id @default(autoincrement()) @db.UnsignedInt
  title      String
  folder     String
  size       Int
  format     String
  uploadedBy Int      @db.UnsignedInt
  createdAt  DateTime @default(now()) @db.DateTime(0)

  uploader          User              @relation("fileUploader", fields: [uploadedBy], references: [id], onDelete: Cascade)
  user              User?             @relation("userProfile")
  serviceCategories ServiceCategory[] @relation("categoryIcon")
}

enum PricingUnit {
  FIXED // One-time flat price
  PER_LEVEL // Price per level (e.g., 1-99 Firemaking)
  PER_KILL // Price per boss kill
  PER_ITEM // Price per item collected
  PER_HOUR // Hourly rate
}

enum ModifierType {
  PERCENTAGE // +10%, +20%, etc.
  FIXED // +50M, -10M, etc.
}

enum ModifierDisplayType {
  NORMAL // Standard modifier display
  UPCHARGE // Highlighted as upcharge (red)
  NOTE // Highlighted as note (green)
  WARNING // Highlighted as warning (yellow)
}

enum PaymentType {
  CRYPTO // Bitcoin, ETH, etc.
  NON_CRYPTO // PayPal, Bank, etc.
}

enum AccountStatus {
  AVAILABLE // Ready to use
  RESERVED // Reserved for order
  IN_USE // Currently being used
  COMPLETED // Service completed
}

enum OrderStatus {
  PENDING // Created, awaiting assignment
  CLAIMING // Posted to job claiming channel
  ASSIGNED // Worker assigned
  IN_PROGRESS // Worker actively working
  AWAITING_CONFIRM // Worker marked complete
  COMPLETED // Customer confirmed
  CANCELLED // Order cancelled
  DISPUTED // Issue reported
  REFUNDED // Refund issued
}

// ============================================
// TICKET SYSTEM ENUMS
// ============================================

enum TicketType {
  PURCHASE_SERVICES_OSRS // Buy OSRS services (Sailing, Agility, etc.)
  PURCHASE_SERVICES_RS3  // Buy RS3 services
  BUY_GOLD_OSRS          // Purchase OSRS gold
  BUY_GOLD_RS3           // Purchase RS3 gold
  SELL_GOLD_OSRS         // Sell OSRS gold to us
  SELL_GOLD_RS3          // Sell RS3 gold to us
  SWAP_CRYPTO            // Swap cryptocurrency
  GENERAL                // General support ticket
}

enum TicketStatus {
  OPEN // Just created, waiting for support
  IN_PROGRESS // Order created, work ongoing
  AWAITING_CONFIRMATION // Worker marked complete
  COMPLETED // Customer confirmed, payouts done
  CANCELLED // Order cancelled
  CLOSED // Ticket closed without order
}

enum TransactionType {
  DEPOSIT // User adds money
  WITHDRAWAL // User withdraws money
  PAYMENT // User pays for service
  REFUND // Refund issued
}

model ServiceCategory {
  id           String    @id @default(uuid())
  name         String
  slug         String    @unique
  emoji        String?
  description  String?   @db.Text
  iconId       Int?      @db.UnsignedInt
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  icon File? @relation("categoryIcon", fields: [iconId], references: [id])

  services Service[] @relation("serviceCategory")
  accounts Account[] @relation("accountCategory")

  // Ticket relations
  tickets        Ticket[]                @relation("categoryTickets")
  ticketSettings CategoryTicketSettings? @relation("categoryTicketSettings")

  @@index([slug])
  @@index([active])
  @@index([displayOrder])
}

model Service {
  id           String    @id @default(uuid())
  categoryId   String
  name         String
  slug         String
  description  String?   @db.Text
  emoji        String?
  imageUrl     String?   // OSRS Wiki image URL for service icon
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  category         ServiceCategory  @relation("serviceCategory", fields: [categoryId], references: [id])
  serviceModifiers ServiceModifier[] @relation("serviceModifiers")
  pricingMethods   PricingMethod[]  @relation("servicePricingMethods")
  accounts         Account[]        @relation("accountService")
  orders           Order[]          @relation("serviceOrders")
  tickets          Ticket[]         @relation("serviceTickets")

  @@unique([categoryId, slug])
  @@index([categoryId])
  @@index([active])
  @@index([displayOrder])
}

model ServiceModifier {
  id           String              @id @default(uuid())
  serviceId    String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  displayType  ModifierDisplayType @default(NORMAL)
  priority     Int                 @default(0)
  condition    String?             @db.Text
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  service Service @relation("serviceModifiers", fields: [serviceId], references: [id])

  @@index([serviceId])
  @@index([priority])
  @@index([active])
}

model PricingMethod {
  id           String      @id @default(uuid())
  serviceId    String
  name         String
  description  String?     @db.Text
  basePrice    Decimal     @db.Decimal(18, 8)
  pricingUnit  PricingUnit @default(FIXED)
  startLevel   Int? // Starting level for level-based pricing (e.g., 1, 40, 50)
  endLevel     Int? // Ending level for level-based pricing (e.g., 40, 50, 99)
  displayOrder Int         @default(0)
  active       Boolean     @default(true)
  createdAt    DateTime    @default(now()) @db.DateTime(0)
  updatedAt    DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  service      Service           @relation("servicePricingMethods", fields: [serviceId], references: [id])
  modifiers    PricingModifier[] @relation("pricingMethodModifiers")
  methodPrices MethodPrice[]     @relation("pricingMethodPrices")
  orders       Order[]           @relation("pricingMethodOrders")

  @@index([serviceId])
  @@index([active])
  @@index([displayOrder])
  @@index([startLevel, endLevel])
}

model PricingModifier {
  id           String              @id @default(uuid())
  methodId     String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  condition    String?             @db.Text // JSON string for complex conditions
  displayType  ModifierDisplayType @default(NORMAL) // How to display this modifier
  priority     Int                 @default(0)
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  method PricingMethod @relation("pricingMethodModifiers", fields: [methodId], references: [id])

  @@index([methodId])
  @@index([priority])
  @@index([active])
}

model PaymentMethod {
  id        String      @id @default(uuid())
  name      String
  type      PaymentType
  active    Boolean     @default(true)
  createdAt DateTime    @default(now()) @db.DateTime(0)
  updatedAt DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt DateTime?

  methodPrices       MethodPrice[]       @relation("paymentMethodPrices")
  orders             Order[]             @relation("paymentMethodOrders")
  tickets            Ticket[]            @relation("paymentMethodTickets")
  walletTransactions WalletTransaction[] @relation("transactionPaymentMethod")

  @@index([type])
  @@index([active])
}

model MethodPrice {
  id              String   @id @default(uuid())
  methodId        String
  paymentMethodId String
  price           Decimal  @db.Decimal(10, 2)
  createdAt       DateTime @default(now()) @db.DateTime(0)
  updatedAt       DateTime @default(now()) @updatedAt() @db.DateTime(0)

  method        PricingMethod @relation("pricingMethodPrices", fields: [methodId], references: [id])
  paymentMethod PaymentMethod @relation("paymentMethodPrices", fields: [paymentMethodId], references: [id])

  @@unique([methodId, paymentMethodId])
  @@index([methodId])
  @@index([paymentMethodId])
}

// Future Models (Schema only - not implemented in this sprint)
model Account {
  id          String        @id @default(uuid())
  categoryId  String
  serviceId   String
  accountData Json // Encrypted account credentials
  status      AccountStatus @default(AVAILABLE)
  reservedAt  DateTime?
  completedAt DateTime?
  createdAt   DateTime      @default(now()) @db.DateTime(0)
  updatedAt   DateTime      @default(now()) @updatedAt() @db.DateTime(0)

  category ServiceCategory @relation("accountCategory", fields: [categoryId], references: [id])
  service  Service         @relation("accountService", fields: [serviceId], references: [id])
  orders   Order[]         @relation("accountOrders")

  @@index([categoryId])
  @@index([serviceId])
  @@index([status])
}

model Order {
  id              String        @id @default(uuid())
  orderNumber     Int           @unique @default(0)

  // Participants
  customerId      Int           @db.UnsignedInt
  workerId        Int?          @db.UnsignedInt    // Null if unassigned
  supportId       Int?          @db.UnsignedInt    // Support who created order

  // Links
  ticketId        String?
  serviceId       String?
  methodId        String?
  paymentMethodId String?
  accountId       String?

  // Discord
  orderChannelId  String?       @unique // Order channel ID
  claimMessageId  String?       // Message in job claiming channel

  // Financials
  orderValue      Decimal       @db.Decimal(18, 8)
  depositAmount   Decimal       @db.Decimal(18, 8)
  currency        String        @default("USD")

  // Payout tracking
  workerPayout    Decimal?      @db.Decimal(18, 8)  // 80%
  supportPayout   Decimal?      @db.Decimal(18, 8)  // 5%
  systemPayout    Decimal?      @db.Decimal(18, 8)  // 15%

  // Status
  status          OrderStatus   @default(PENDING)

  // Job details (for worker)
  jobDetails      Json?

  // Notes
  completionNotes   String?       @db.Text
  cancellationReason String?      @db.Text

  // Timestamps
  createdAt       DateTime      @default(now()) @db.DateTime(0)
  updatedAt       DateTime      @default(now()) @updatedAt @db.DateTime(0)
  assignedAt      DateTime?
  claimedAt       DateTime?
  startedAt       DateTime?
  completedAt     DateTime?
  confirmedAt     DateTime?
  cancelledAt     DateTime?

  // Relations
  customer          User           @relation("customerOrders", fields: [customerId], references: [id])
  worker            User?          @relation("workerOrders", fields: [workerId], references: [id])
  support           User?          @relation("supportOrders", fields: [supportId], references: [id])
  ticket            Ticket?        @relation("ticketOrders", fields: [ticketId], references: [id])
  service           Service?       @relation("serviceOrders", fields: [serviceId], references: [id])
  method            PricingMethod? @relation("pricingMethodOrders", fields: [methodId], references: [id])
  paymentMethod     PaymentMethod? @relation("paymentMethodOrders", fields: [paymentMethodId], references: [id])
  account           Account?       @relation("accountOrders", fields: [accountId], references: [id])
  legacyTransactions Transaction[] @relation("orderTransactions")
  walletTransactions WalletTransaction[] @relation("orderWalletTransactions")
  statusHistory     OrderStatusHistory[]

  @@index([customerId])
  @@index([workerId])
  @@index([status])
  @@index([ticketId])
  @@index([createdAt])
}

model OrderStatusHistory {
  id          String       @id @default(uuid())
  orderId     String
  fromStatus  OrderStatus?
  toStatus    OrderStatus
  changedById Int          @db.UnsignedInt
  reason      String?      @db.Text
  createdAt   DateTime     @default(now()) @db.DateTime(0)

  order       Order        @relation(fields: [orderId], references: [id])
  changedBy   User         @relation("statusChangeHistory", fields: [changedById], references: [id])

  @@index([orderId])
}

model Transaction {
  id        String          @id @default(uuid())
  userId    Int             @db.UnsignedInt
  orderId   String?
  type      TransactionType
  amount    Decimal         @db.Decimal(10, 2)
  currency  String          @default("USD")
  status    String          @default("PENDING")
  createdAt DateTime        @default(now()) @db.DateTime(0)

  user  User   @relation("userTransactions", fields: [userId], references: [id])
  order Order? @relation("orderTransactions", fields: [orderId], references: [id])

  @@index([userId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

// Wallet Types
enum WalletType {
  CUSTOMER
  WORKER
  SUPPORT
}

// Wallet Transaction Types
enum WalletTransactionType {
  DEPOSIT           // Customer adds funds
  WITHDRAWAL        // User withdraws funds
  PAYMENT           // Payment for order (locks funds)
  REFUND            // Order refunded
  EARNING           // Worker payout (80%)
  COMMISSION        // Support commission (5%)
  SYSTEM_FEE        // System takes cut (15%)
  ADJUSTMENT        // Manual correction
  RELEASE           // Release locked funds after order complete
}

// Wallet Transaction Status
enum WalletTransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REVERSED
}

model Wallet {
  id              String      @id @default(uuid())
  userId          Int         @unique @db.UnsignedInt
  walletType      WalletType  @default(CUSTOMER)
  balance         Decimal     @default(0) @db.Decimal(18, 8)
  pendingBalance  Decimal     @default(0) @db.Decimal(18, 8) // Locked for orders
  currency        String      @default("USD")
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now()) @db.DateTime(0)
  updatedAt       DateTime    @default(now()) @updatedAt() @db.DateTime(0)

  user            User        @relation("userWallet", fields: [userId], references: [id])
  transactions    WalletTransaction[]

  @@index([userId])
  @@index([walletType])
}

model WalletTransaction {
  id              String                    @id @default(uuid())
  walletId        String
  orderId         String?
  type            WalletTransactionType
  amount          Decimal                   @db.Decimal(18, 8)
  balanceBefore   Decimal                   @db.Decimal(18, 8)
  balanceAfter    Decimal                   @db.Decimal(18, 8)
  currency        String                    @default("USD")
  status          WalletTransactionStatus   @default(COMPLETED)

  // Payment details
  paymentMethodId String?
  reference       String?                   // External transaction ID
  notes           String?                   @db.Text

  // Actor who created this transaction
  createdById     Int                       @db.UnsignedInt

  createdAt       DateTime                  @default(now()) @db.DateTime(0)

  wallet          Wallet                    @relation(fields: [walletId], references: [id])
  order           Order?                    @relation("orderWalletTransactions", fields: [orderId], references: [id])
  paymentMethod   PaymentMethod?            @relation("transactionPaymentMethod", fields: [paymentMethodId], references: [id])
  createdBy       User                      @relation("transactionCreator", fields: [createdById], references: [id])

  @@index([walletId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

// System Wallet (singleton for system funds)
model SystemWallet {
  id        String   @id @default("system-wallet")
  balance   Decimal  @default(0) @db.Decimal(18, 8)
  currency  String   @default("USD")
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)
}

model DiscordMessage {
  id          String    @id @default(uuid())
  messageId   String    @unique
  channelId   String
  messageType String // "CATEGORY_LIST", "SERVICE_DETAIL", "GROUPED_CATEGORIES"
  categoryId  String?
  serviceId   String?
  groupIndex  Int? // For grouped messages (0, 1, 2, etc.)
  createdAt   DateTime  @default(now()) @db.DateTime(0)
  expiresAt   DateTime? @db.DateTime(0)

  @@index([messageId])
  @@index([channelId])
  @@index([messageType])
}

// OSRS Experience Table (levels 1-99)
model ExperienceTable {
  level      Int @id @db.UnsignedTinyInt // 1-99
  experience BigInt // Total XP required for this level
  difference Int // XP difference from previous level

  @@index([level])
}

// ============================================
// TICKET SYSTEM MODELS
// ============================================

model Ticket {
  id              String        @id @default(uuid())
  ticketNumber    Int           @unique @default(autoincrement())

  // Ticket Type (NEW)
  ticketType      TicketType    @default(GENERAL)

  // Customer who opened the ticket
  customerId      Int           @db.UnsignedInt
  customerDiscordId String      // Discord user ID of customer

  // Category and service context
  categoryId      String
  serviceId       String?

  // Discord channel info
  channelId       String        @unique // Discord channel ID for this ticket

  // Pricing info from calculator (optional)
  calculatedPrice Decimal?      @db.Decimal(18, 8)
  paymentMethodId String?
  currency        String        @default("USD")

  // Status tracking
  status          TicketStatus  @default(OPEN)

  // Support who handled the ticket
  supportId       Int?          @db.UnsignedInt
  supportDiscordId String?

  // Additional notes from customer
  customerNotes   String?       @db.Text

  // Timestamps
  createdAt       DateTime      @default(now()) @db.DateTime(0)
  updatedAt       DateTime      @default(now()) @updatedAt @db.DateTime(0)
  closedAt        DateTime?     @db.DateTime(0)

  // Relations
  customer        User          @relation("customerTickets", fields: [customerId], references: [id])
  support         User?         @relation("supportTickets", fields: [supportId], references: [id])
  category        ServiceCategory @relation("categoryTickets", fields: [categoryId], references: [id])
  service         Service?      @relation("serviceTickets", fields: [serviceId], references: [id])
  paymentMethod   PaymentMethod? @relation("paymentMethodTickets", fields: [paymentMethodId], references: [id])
  messages        TicketMessage[]
  orders          Order[]       @relation("ticketOrders")
  metadata        TicketMetadata? @relation("ticketMetadata")

  @@index([customerId])
  @@index([categoryId])
  @@index([serviceId])
  @@index([status])
  @@index([channelId])
  @@index([ticketType])
  @@index([createdAt])
}

model TicketMessage {
  id        String   @id @default(uuid())
  ticketId  String

  // Message author
  authorId  Int      @db.UnsignedInt
  authorDiscordId String // Discord user ID
  authorName String   // Display name at time of message

  // Message content
  content   String   @db.Text

  // Message type
  isSystem  Boolean  @default(false) // Auto-generated system messages
  isWelcome Boolean  @default(false) // Welcome message

  // Discord message reference
  discordMessageId String? @unique

  createdAt DateTime @default(now()) @db.DateTime(0)

  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author    User     @relation("ticketMessageAuthor", fields: [authorId], references: [id])

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
}

// Category-specific ticket welcome message settings
model CategoryTicketSettings {
  id              String    @id @default(uuid())
  categoryId      String    @unique

  // Banner image
  bannerUrl       String?   @db.Text

  // Welcome message content
  welcomeTitle    String?   @db.VarChar(255)
  welcomeMessage  String    @db.Text  // Rich text / Markdown supported

  // Footer text
  footerText      String?   @db.Text

  // Embed color (hex without #)
  embedColor      String?   @db.VarChar(6) @default("5865F2")

  // Toggle
  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now()) @db.DateTime(0)
  updatedAt       DateTime  @default(now()) @updatedAt @db.DateTime(0)

  category        ServiceCategory @relation("categoryTicketSettings", fields: [categoryId], references: [id], onDelete: Cascade)
}

// Ticket metadata for gold/crypto transactions
model TicketMetadata {
  id              String    @id @default(uuid())
  ticketId        String    @unique

  // Gold transaction fields
  goldAmount      Decimal?  @db.Decimal(15, 2)      // Amount in millions (e.g., 100M)
  goldRate        Decimal?  @db.Decimal(10, 4)      // Rate per M (e.g., $0.45/M)
  deliveryMethod  String?   @db.VarChar(100)        // F2P, P2P, Drop Trading, etc.
  worldLocation   String?   @db.VarChar(200)        // "W301, Grand Exchange"
  osrsUsername    String?   @db.VarChar(100)        // Customer's OSRS/RS3 username

  // Crypto transaction fields
  cryptoType      String?   @db.VarChar(50)         // BTC, ETH, USDT, etc.
  cryptoAmount    Decimal?  @db.Decimal(20, 8)      // Crypto amount
  walletAddress   String?   @db.VarChar(500)        // Customer's wallet address
  swapDirection   String?   @db.VarChar(50)         // CRYPTO_TO_GOLD or GOLD_TO_CRYPTO

  // Payment details (for sell gold)
  paymentEmail    String?   @db.VarChar(255)        // PayPal email or similar
  paymentProof    String?   @db.Text                // URL to payment proof
  payoutAmount    Decimal?  @db.Decimal(18, 8)      // Amount paid to customer

  // Additional notes
  specialNotes    String?   @db.Text
  internalNotes   String?   @db.Text                // Staff-only notes

  createdAt       DateTime  @default(now()) @db.DateTime(0)
  updatedAt       DateTime  @default(now()) @updatedAt @db.DateTime(0)

  ticket          Ticket    @relation("ticketMetadata", fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
}

// Ticket Type Settings - Customization per ticket type
model TicketTypeSettings {
  id              String     @id @default(uuid())
  ticketType      TicketType @unique

  // Grouping (for types that share welcome messages)
  groupKey        String?    @db.VarChar(50)
  buttonLabel     String?    @db.VarChar(100)
  buttonColor     String?    @db.VarChar(20) // "green", "blue", "red", "gray"
  displayOrder    Int        @default(0)

  // Welcome message customization (shared across group if groupKey is set)
  bannerUrl       String?    @db.Text
  thumbnailUrl    String?    @db.Text
  welcomeTitle    String?    @db.VarChar(255)
  welcomeMessage  String     @db.Text
  footerText      String?    @db.Text
  embedColor      String?    @db.VarChar(6) @default("5865F2")

  // Dynamic form fields (JSON array) - unique per type
  // Each field: { id, label, type, required, placeholder, options[], min, max }
  customFields    Json?

  // Auto-assignment settings
  autoAssign      Boolean    @default(false)

  // Notification settings
  notifyOnCreate  Boolean    @default(true)
  notifyOnClose   Boolean    @default(true)
  mentionSupport  Boolean    @default(true)
  mentionCustomer Boolean    @default(true)

  // Active toggle (per type - can disable RS3 but keep OSRS active)
  isActive        Boolean    @default(true)

  createdAt       DateTime   @default(now()) @db.DateTime(0)
  updatedAt       DateTime   @default(now()) @updatedAt @db.DateTime(0)

  @@index([ticketType])
  @@index([isActive])
  @@index([groupKey])
}
