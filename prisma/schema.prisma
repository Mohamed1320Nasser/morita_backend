generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  admin
  system
  tester
  user
}

enum DiscordRole {
  admin
  support
  worker
  customer
}

enum OtpType {
  verify_email
  forget_email
}

model User {
  id                  Int       @id @default(autoincrement()) @db.UnsignedInt
  fullname            String
  username            String?   @unique
  email               String    @unique
  phone               String?
  password            String?
  profileId           Int?      @unique @db.UnsignedInt
  emailIsVerified     Boolean   @default(false)
  emailVerifyToken    String?
  passwordSetupToken  String?   @unique
  passwordSetupExpiry DateTime? @db.DateTime(0)
  banned              Boolean   @default(false)
  role                Role      @default(user)
  createdAt           DateTime  @default(now()) @db.DateTime(0)
  updatedAt           DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt           DateTime?

  discordId          String?      @unique
  discordUsername    String?
  discordDisplayName String?
  discordRole        DiscordRole? @default(customer)

  sessions                  Session[]
  otpRequests               OtpRequest[]
  files                     File[]               @relation("fileUploader")
  profile                   File?                @relation("userProfile", fields: [profileId], references: [id])
  customerOrders            Order[]              @relation("customerOrders")
  workerOrders              Order[]              @relation("workerOrders")
  supportOrders             Order[]              @relation("supportOrders")
  statusChangeHistory       OrderStatusHistory[] @relation("statusChangeHistory")
  transactions              Transaction[]        @relation("userTransactions")
  wallet                    Wallet?              @relation("userWallet")
  walletTransactionsCreated WalletTransaction[]  @relation("transactionCreator")
  customerTickets           Ticket[]             @relation("customerTickets")
  supportTickets            Ticket[]             @relation("supportTickets")
  ticketMessages            TicketMessage[]      @relation("ticketMessageAuthor")
  tosAcceptances            TosAcceptance[]      @relation("userTosAcceptances")
  onboardingAnswers         OnboardingAnswer[]   @relation("userOnboardingAnswers")
  reportedIssues            OrderIssue[]         @relation("reportedIssues")
  resolvedIssues            OrderIssue[]         @relation("resolvedIssues")
  reservedAccounts          Account[]            @relation("accountReservedBy")
  purchasedAccounts         Account[]            @relation("accountSoldTo")
  soldAccounts              Account[]            @relation("accountSoldBy")
  dailyRewardClaims         DailyRewardClaim[]   @relation("userDailyRewardClaims")
  orderRewardClaims         OrderRewardClaim[]   @relation("userOrderRewardClaims")

  @@index([email])
  @@index([role])
  @@index([discordId])
  @@index([discordRole])
}

model Session {
  id            Int       @id @default(autoincrement()) @db.UnsignedInt
  token         String    @unique
  identifier    String
  userId        Int       @db.UnsignedInt
  tenantId      String?
  companyId     Int?      @db.UnsignedInt
  source        String?
  langCode      String?
  expired       Boolean   @default(false)
  expired_since DateTime? @db.DateTime(0)
  createdAt     DateTime  @default(now()) @db.DateTime(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tenantId])
  @@index([companyId])
}

model OtpRequest {
  id        String   @id @default(uuid())
  userId    Int?     @db.UnsignedInt
  email     String?
  otp       String
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  expiredAt DateTime @default(now()) @db.DateTime(0)
  createdAt DateTime @default(now()) @db.DateTime(0)
  type      OtpType

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
}

model File {
  id         Int      @id @default(autoincrement()) @db.UnsignedInt
  title      String
  folder     String
  size       Int
  format     String
  uploadedBy Int      @db.UnsignedInt
  createdAt  DateTime @default(now()) @db.DateTime(0)

  uploader          User              @relation("fileUploader", fields: [uploadedBy], references: [id], onDelete: Cascade)
  user              User?             @relation("userProfile")
  serviceCategories ServiceCategory[] @relation("categoryIcon")
  accountImages     AccountImage[]    @relation("accountImages")
}

enum PricingUnit {
  FIXED
  PER_LEVEL
  PER_KILL
  PER_ITEM
  PER_HOUR
}

enum ModifierType {
  PERCENTAGE
  FIXED
}

enum ModifierDisplayType {
  NORMAL
  UPCHARGE
  DISCOUNT
  NOTE
  WARNING
}

enum PaymentType {
  CRYPTO
  NON_CRYPTO
}

enum AccountStatus {
  IN_STOCK
  RESERVED
  SOLD
}

enum AccountCategory {
  MAIN
  IRONS
  HCIM
  ZERK
  PURE
  ACCOUNTS
}

enum OrderStatus {
  PENDING
  CLAIMING
  ASSIGNED
  IN_PROGRESS
  AWAITING_CONFIRM
  COMPLETED
  CANCELLED
  DISPUTED
  REFUNDED
}

enum TicketType {
  PURCHASE_SERVICES_OSRS
  PURCHASE_SERVICES_RS3
  BUY_GOLD_OSRS
  BUY_GOLD_RS3
  SELL_GOLD_OSRS
  SELL_GOLD_RS3
  SWAP_CRYPTO
  PURCHASE_ACCOUNT
  GENERAL
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  AWAITING_CONFIRMATION
  COMPLETED
  CANCELLED
  CLOSED
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
}

model ServiceCategory {
  id           String    @id @default(uuid())
  name         String
  slug         String    @unique
  emoji        String?
  description  String?   @db.Text
  iconId       Int?      @db.UnsignedInt
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  icon           File?                   @relation("categoryIcon", fields: [iconId], references: [id])
  services       Service[]               @relation("serviceCategory")
  tickets        Ticket[]                @relation("categoryTickets")
  ticketSettings CategoryTicketSettings? @relation("categoryTicketSettings")

  @@index([slug])
  @@index([active])
  @@index([displayOrder])
}

model Service {
  id           String    @id @default(uuid())
  categoryId   String
  name         String
  slug         String
  description  String?   @db.Text
  emoji        String?
  imageUrl     String?
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  category         ServiceCategory   @relation("serviceCategory", fields: [categoryId], references: [id])
  serviceModifiers ServiceModifier[] @relation("serviceModifiers")
  pricingMethods   PricingMethod[]   @relation("servicePricingMethods")
  orders           Order[]           @relation("serviceOrders")
  tickets          Ticket[]          @relation("serviceTickets")

  shortcuts Json?

  @@unique([categoryId, slug])
  @@index([categoryId])
  @@index([active])
  @@index([displayOrder])
}

model ServiceModifier {
  id           String              @id @default(uuid())
  serviceId    String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  displayType  ModifierDisplayType @default(NORMAL)
  priority     Int                 @default(0)
  condition    String?             @db.Text
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  service Service @relation("serviceModifiers", fields: [serviceId], references: [id])

  @@index([serviceId])
  @@index([priority])
  @@index([active])
}

model PricingMethod {
  id           String      @id @default(uuid())
  serviceId    String
  name         String
  groupName    String?
  description  String?     @db.Text
  basePrice    Decimal     @db.Decimal(18, 8)
  pricingUnit  PricingUnit @default(FIXED)
  startLevel   Int?
  endLevel     Int?
  displayOrder Int         @default(0)
  active       Boolean     @default(true)
  createdAt    DateTime    @default(now()) @db.DateTime(0)
  updatedAt    DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  service      Service           @relation("servicePricingMethods", fields: [serviceId], references: [id])
  modifiers    PricingModifier[] @relation("pricingMethodModifiers")
  methodPrices MethodPrice[]     @relation("pricingMethodPrices")
  orders       Order[]           @relation("pricingMethodOrders")

  shortcuts Json?

  @@index([serviceId])
  @@index([active])
  @@index([displayOrder])
  @@index([startLevel, endLevel])
  @@index([groupName])
}

model PricingModifier {
  id           String              @id @default(uuid())
  methodId     String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  condition    String?             @db.Text
  displayType  ModifierDisplayType @default(NORMAL)
  priority     Int                 @default(0)
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  method PricingMethod @relation("pricingMethodModifiers", fields: [methodId], references: [id])

  @@index([methodId])
  @@index([priority])
  @@index([active])
}

model PaymentMethod {
  id        String      @id @default(uuid())
  name      String
  type      PaymentType
  active    Boolean     @default(true)
  createdAt DateTime    @default(now()) @db.DateTime(0)
  updatedAt DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt DateTime?

  methodPrices       MethodPrice[]       @relation("paymentMethodPrices")
  orders             Order[]             @relation("paymentMethodOrders")
  tickets            Ticket[]            @relation("paymentMethodTickets")
  walletTransactions WalletTransaction[] @relation("transactionPaymentMethod")

  @@index([type])
  @@index([active])
}

model MethodPrice {
  id              String   @id @default(uuid())
  methodId        String
  paymentMethodId String
  price           Decimal  @db.Decimal(10, 2)
  createdAt       DateTime @default(now()) @db.DateTime(0)
  updatedAt       DateTime @default(now()) @updatedAt() @db.DateTime(0)

  method        PricingMethod @relation("pricingMethodPrices", fields: [methodId], references: [id])
  paymentMethod PaymentMethod @relation("paymentMethodPrices", fields: [paymentMethodId], references: [id])

  @@unique([methodId, paymentMethodId])
  @@index([methodId])
  @@index([paymentMethodId])
}

model Account {
  id String @id @default(uuid())

  name              String
  price             Decimal         @db.Decimal(10, 2)
  quantity          Int             @default(1)
  source            String?
  category          AccountCategory
  accountData       Json?
  status            AccountStatus   @default(IN_STOCK)

  // Reservation tracking
  reservedById      Int?            @db.UnsignedInt
  reservedAt        DateTime?       @db.DateTime(0)
  reservationExpiry DateTime?       @db.DateTime(0)

  // Sale tracking
  soldToId          Int?            @db.UnsignedInt
  soldById          Int?            @db.UnsignedInt  // Support staff who delivered the account
  soldAt            DateTime?       @db.DateTime(0)

  createdAt         DateTime        @default(now()) @db.DateTime(0)
  updatedAt         DateTime        @default(now()) @updatedAt() @db.DateTime(0)

  images     AccountImage[]
  reservedBy User?          @relation("accountReservedBy", fields: [reservedById], references: [id])
  soldTo     User?          @relation("accountSoldTo", fields: [soldToId], references: [id])
  soldBy     User?          @relation("accountSoldBy", fields: [soldById], references: [id])
  tickets    Ticket[]       @relation("ticketAccount")
  orders     Order[]        @relation("accountOrders")

  @@index([category])
  @@index([status])
  @@index([reservedById])
  @@index([soldToId])
  @@index([soldById])
}

model AccountImage {
  id        String   @id @default(uuid())
  accountId String
  fileId    Int      @db.UnsignedInt
  createdAt DateTime @default(now()) @db.DateTime(0)

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  file    File    @relation("accountImages", fields: [fileId], references: [id], onDelete: Cascade)

  @@index([accountId])
  @@index([fileId])
}

model Order {
  id          String @id @default(uuid())
  orderNumber Int    @unique @default(0)

  customerId      Int     @db.UnsignedInt
  workerId        Int?    @db.UnsignedInt
  supportId       Int?    @db.UnsignedInt
  ticketId        String?
  serviceId       String?
  methodId        String?
  paymentMethodId String?
  accountId       String?
  orderChannelId  String? @unique
  claimMessageId  String?
  pinnedMessageId String?
  ticketChannelId String?
  orderValue      Decimal @db.Decimal(18, 8)
  depositAmount   Decimal @db.Decimal(18, 8)
  currency        String  @default("USD")

  workerPayout       Decimal?    @db.Decimal(18, 8)
  supportPayout      Decimal?    @db.Decimal(18, 8)
  systemPayout       Decimal?    @db.Decimal(18, 8)
  payoutProcessed    Boolean     @default(false)
  status             OrderStatus @default(PENDING)
  jobDetails         Json?
  completionNotes    String?     @db.Text
  proofScreenshots   Json?       // All screenshots uploaded by worker (via /add-proof and completion)
  cancellationReason String?     @db.Text
  rating             Int?
  review             String?     @db.Text
  reviewedAt         DateTime?   @db.DateTime(0)
  createdAt          DateTime    @default(now()) @db.DateTime(0)
  updatedAt          DateTime    @default(now()) @updatedAt @db.DateTime(0)
  assignedAt         DateTime?
  claimedAt          DateTime?
  startedAt          DateTime?
  completedAt        DateTime?
  confirmedAt        DateTime?
  cancelledAt        DateTime?
  version            Int         @default(0)

  customer           User                 @relation("customerOrders", fields: [customerId], references: [id])
  worker             User?                @relation("workerOrders", fields: [workerId], references: [id])
  support            User?                @relation("supportOrders", fields: [supportId], references: [id])
  ticket             Ticket?              @relation("ticketOrders", fields: [ticketId], references: [id])
  service            Service?             @relation("serviceOrders", fields: [serviceId], references: [id])
  method             PricingMethod?       @relation("pricingMethodOrders", fields: [methodId], references: [id])
  paymentMethod      PaymentMethod?       @relation("paymentMethodOrders", fields: [paymentMethodId], references: [id])
  account            Account?             @relation("accountOrders", fields: [accountId], references: [id])
  legacyTransactions Transaction[]        @relation("orderTransactions")
  walletTransactions WalletTransaction[]  @relation("orderWalletTransactions")
  statusHistory      OrderStatusHistory[]
  issues             OrderIssue[]
  orderRewardClaim   OrderRewardClaim?    @relation("orderRewardClaim")
  accountData        OrderAccountData?

  @@index([customerId])
  @@index([workerId])
  @@index([status])
  @@index([ticketId])
  @@index([accountId])
  @@index([createdAt])
  @@index([workerId, status])
  @@index([customerId, status])
}

model OrderStatusHistory {
  id          String       @id @default(uuid())
  orderId     String
  fromStatus  OrderStatus?
  toStatus    OrderStatus
  changedById Int          @db.UnsignedInt
  reason      String?      @db.Text
  createdAt   DateTime     @default(now()) @db.DateTime(0)

  order     Order @relation(fields: [orderId], references: [id])
  changedBy User  @relation("statusChangeHistory", fields: [changedById], references: [id])

  @@index([orderId])
}

enum IssueStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

enum IssuePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model OrderIssue {
  id               String        @id @default(uuid())
  orderId          String
  reportedById     Int           @db.UnsignedInt
  issueDescription String        @db.Text
  status           IssueStatus   @default(OPEN)
  priority         IssuePriority @default(MEDIUM)
  resolution       String?       @db.Text
  resolvedById     Int?          @db.UnsignedInt
  discordMessageId String?
  discordChannelId String?
  createdAt        DateTime      @default(now()) @db.DateTime(0)
  updatedAt        DateTime      @default(now()) @updatedAt @db.DateTime(0)
  resolvedAt       DateTime?     @db.DateTime(0)

  order      Order @relation(fields: [orderId], references: [id])
  reportedBy User  @relation("reportedIssues", fields: [reportedById], references: [id])
  resolvedBy User? @relation("resolvedIssues", fields: [resolvedById], references: [id])

  @@index([orderId])
  @@index([reportedById])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
}

model Transaction {
  id        String          @id @default(uuid())
  userId    Int             @db.UnsignedInt
  orderId   String?
  type      TransactionType
  amount    Decimal         @db.Decimal(10, 2)
  currency  String          @default("USD")
  status    String          @default("PENDING")
  createdAt DateTime        @default(now()) @db.DateTime(0)

  user  User   @relation("userTransactions", fields: [userId], references: [id])
  order Order? @relation("orderTransactions", fields: [orderId], references: [id])

  @@index([userId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

enum WalletType {
  CUSTOMER
  WORKER
  SUPPORT
}

enum WalletTransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
  EARNING
  COMMISSION
  SYSTEM_FEE
  ADJUSTMENT
  RELEASE
  WORKER_DEPOSIT
  DAILY_REWARD
  ORDER_REWARD
}

enum OrderRewardType {
  FIXED
  PERCENTAGE
}

enum WalletTransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REVERSED
}

model Wallet {
  id             String     @id @default(uuid())
  userId         Int        @unique @db.UnsignedInt
  walletType     WalletType @default(CUSTOMER)
  balance        Decimal    @default(0) @db.Decimal(18, 8)
  pendingBalance Decimal    @default(0) @db.Decimal(18, 8)
  deposit        Decimal    @default(0) @db.Decimal(18, 8)
  currency       String     @default("USD")
  isActive       Boolean    @default(true)
  createdAt      DateTime   @default(now()) @db.DateTime(0)
  updatedAt      DateTime   @default(now()) @updatedAt() @db.DateTime(0)

  user         User                @relation("userWallet", fields: [userId], references: [id])
  transactions WalletTransaction[]

  @@index([userId])
  @@index([walletType])
}

model WalletTransaction {
  id              String                  @id @default(uuid())
  walletId        String
  orderId         String?
  type            WalletTransactionType
  amount          Decimal                 @db.Decimal(18, 8)
  balanceBefore   Decimal                 @db.Decimal(18, 8)
  balanceAfter    Decimal                 @db.Decimal(18, 8)
  depositBefore   Decimal?                @db.Decimal(18, 8)
  depositAfter    Decimal?                @db.Decimal(18, 8)
  currency        String                  @default("USD")
  status          WalletTransactionStatus @default(COMPLETED)
  paymentMethodId String?
  reference       String?
  notes           String?                 @db.Text
  createdById     Int                     @db.UnsignedInt
  createdAt       DateTime                @default(now()) @db.DateTime(0)

  wallet        Wallet         @relation(fields: [walletId], references: [id])
  order         Order?         @relation("orderWalletTransactions", fields: [orderId], references: [id])
  paymentMethod PaymentMethod? @relation("transactionPaymentMethod", fields: [paymentMethodId], references: [id])
  createdBy     User           @relation("transactionCreator", fields: [createdById], references: [id])

  @@index([walletId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

model SystemWallet {
  id        String   @id @default("system-wallet")
  balance   Decimal  @default(0) @db.Decimal(18, 8)
  currency  String   @default("USD")
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)
}

model DiscordMessage {
  id          String    @id @default(uuid())
  messageId   String    @unique
  channelId   String
  messageType String
  categoryId  String?
  serviceId   String?
  groupIndex  Int?
  isPinned    Boolean   @default(false)
  createdAt   DateTime  @default(now()) @db.DateTime(0)
  updatedAt   DateTime  @default(now()) @updatedAt @db.DateTime(0)
  expiresAt   DateTime? @db.DateTime(0)

  @@index([messageId])
  @@index([channelId])
  @@index([messageType])
}

model ExperienceTable {
  level      Int    @id @db.UnsignedTinyInt
  experience BigInt
  difference Int

  @@index([level])
}

model Ticket {
  id                String       @id @default(uuid())
  ticketNumber      Int          @unique @default(autoincrement())
  ticketType        TicketType   @default(GENERAL)
  customerId        Int          @db.UnsignedInt
  customerDiscordId String
  categoryId        String?
  serviceId         String?
  accountId         String?
  channelId         String       @unique
  calculatedPrice   Decimal?     @db.Decimal(18, 8)
  paymentMethodId   String?
  currency          String       @default("USD")
  status            TicketStatus @default(OPEN)
  supportId         Int?         @db.UnsignedInt
  supportDiscordId  String?
  customerNotes     String?      @db.Text
  createdAt         DateTime     @default(now()) @db.DateTime(0)
  updatedAt         DateTime     @default(now()) @updatedAt @db.DateTime(0)
  closedAt          DateTime?    @db.DateTime(0)

  customer      User             @relation("customerTickets", fields: [customerId], references: [id])
  support       User?            @relation("supportTickets", fields: [supportId], references: [id])
  category      ServiceCategory? @relation("categoryTickets", fields: [categoryId], references: [id])
  service       Service?         @relation("serviceTickets", fields: [serviceId], references: [id])
  paymentMethod PaymentMethod?   @relation("paymentMethodTickets", fields: [paymentMethodId], references: [id])
  account       Account?         @relation("ticketAccount", fields: [accountId], references: [id])
  messages      TicketMessage[]
  orders        Order[]          @relation("ticketOrders")
  metadata      TicketMetadata?  @relation("ticketMetadata")

  @@index([customerId])
  @@index([categoryId])
  @@index([serviceId])
  @@index([accountId])
  @@index([status])
  @@index([channelId])
  @@index([ticketType])
  @@index([createdAt])
}

model TicketMessage {
  id               String   @id @default(uuid())
  ticketId         String
  authorId         Int      @db.UnsignedInt
  authorDiscordId  String
  authorName       String
  content          String   @db.Text
  isSystem         Boolean  @default(false)
  isWelcome        Boolean  @default(false)
  discordMessageId String?  @unique
  createdAt        DateTime @default(now()) @db.DateTime(0)

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author User   @relation("ticketMessageAuthor", fields: [authorId], references: [id])

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
}

model CategoryTicketSettings {
  id             String   @id @default(uuid())
  categoryId     String   @unique
  bannerUrl      String?  @db.Text
  welcomeTitle   String?  @db.VarChar(255)
  welcomeMessage String   @db.Text
  footerText     String?  @db.Text
  embedColor     String?  @default("5865F2") @db.VarChar(6)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now()) @db.DateTime(0)
  updatedAt      DateTime @default(now()) @updatedAt @db.DateTime(0)

  category ServiceCategory @relation("categoryTicketSettings", fields: [categoryId], references: [id], onDelete: Cascade)
}

model TicketMetadata {
  id       String @id @default(uuid())
  ticketId String @unique

  goldAmount     Decimal? @db.Decimal(15, 2) // Amount in millions (e.g., 100M)
  goldRate       Decimal? @db.Decimal(10, 4) // Rate per M (e.g., $0.45/M)
  deliveryMethod String?  @db.VarChar(100) // F2P, P2P, Drop Trading, etc.
  worldLocation  String?  @db.VarChar(200) // "W301, Grand Exchange"
  osrsUsername   String?  @db.VarChar(100) // Customer's OSRS/RS3 username
  cryptoType     String?  @db.VarChar(50) // BTC, ETH, USDT, etc.
  cryptoAmount   Decimal? @db.Decimal(20, 8) // Crypto amount
  walletAddress  String?  @db.VarChar(500)
  swapDirection  String?  @db.VarChar(50)
  paymentEmail   String?  @db.VarChar(255)
  paymentProof   String?  @db.Text
  payoutAmount   Decimal? @db.Decimal(18, 8)
  specialNotes   String?  @db.Text
  internalNotes  String?  @db.Text // Staff-only notes
  createdAt      DateTime @default(now()) @db.DateTime(0)
  updatedAt      DateTime @default(now()) @updatedAt @db.DateTime(0)

  ticket Ticket @relation("ticketMetadata", fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
}

// Ticket Type Settings - Customization per ticket type
model TicketTypeSettings {
  id         String     @id @default(uuid())
  ticketType TicketType @unique

  // Grouping (for types that share welcome messages)
  groupKey     String? @db.VarChar(50)
  buttonLabel  String? @db.VarChar(100)
  buttonColor  String? @db.VarChar(20) // "green", "blue", "red", "gray"
  displayOrder Int     @default(0)

  // Welcome message customization (shared across group if groupKey is set)
  bannerUrl      String? @db.Text
  thumbnailUrl   String? @db.Text
  welcomeTitle   String? @db.VarChar(255)
  welcomeMessage String  @db.Text
  footerText     String? @db.Text
  embedColor     String? @default("5865F2") @db.VarChar(6)

  // Dynamic form fields (JSON array) - unique per type
  // Each field: { id, label, type, required, placeholder, options[], min, max }
  customFields Json?

  // Auto-assignment settings
  autoAssign Boolean @default(false)

  // Notification settings
  notifyOnCreate  Boolean @default(true)
  notifyOnClose   Boolean @default(true)
  mentionSupport  Boolean @default(true)
  mentionCustomer Boolean @default(true)

  // Active toggle (per type - can disable RS3 but keep OSRS active)
  isActive Boolean @default(true)

  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  @@index([ticketType])
  @@index([isActive])
  @@index([groupKey])
}

// ============================================
// ONBOARDING SYSTEM
// ============================================

// Terms of Service Content
model TermsOfService {
  id           String   @id @default(uuid())
  title        String   @db.VarChar(255)
  content      String   @db.Text // Main TOS text content
  bannerUrl    String?  @db.Text // GIF/Image URL for banner
  thumbnailUrl String?  @db.Text // Thumbnail image
  embedColor   String   @default("5865F2") @db.VarChar(6) // Hex color without #
  footerText   String?  @db.Text
  buttonLabel  String   @default("Accept Terms") @db.VarChar(100)
  isActive     Boolean  @default(true)
  version      Int      @default(1) // Track TOS versions
  createdAt    DateTime @default(now()) @db.DateTime(0)
  updatedAt    DateTime @default(now()) @updatedAt @db.DateTime(0)

  acceptances TosAcceptance[]

  @@index([isActive])
  @@index([version])
}

model TosAcceptance {
  id              String   @id @default(uuid())
  userId          Int      @db.UnsignedInt
  tosId           String
  discordId       String // Discord user ID
  discordUsername String
  acceptedAt      DateTime @default(now()) @db.DateTime(0)
  ipAddress       String?  @db.VarChar(45) // Optional: track IP

  user User           @relation("userTosAcceptances", fields: [userId], references: [id])
  tos  TermsOfService @relation(fields: [tosId], references: [id])

  @@unique([userId, tosId])
  @@index([discordId])
  @@index([acceptedAt])
}

model OnboardingQuestion {
  id           String            @id @default(uuid())
  question     String            @db.Text
  fieldType    QuestionFieldType @default(TEXT)
  placeholder  String?           @db.VarChar(255)
  required     Boolean           @default(true)
  minLength    Int? // For text validation
  maxLength    Int? // For text validation
  displayOrder Int               @default(0)
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now()) @db.DateTime(0)
  updatedAt    DateTime          @default(now()) @updatedAt @db.DateTime(0)

  answers OnboardingAnswer[]

  @@index([displayOrder])
  @@index([isActive])
}

enum QuestionFieldType {
  TEXT // Short text input (Discord TextInputStyle.Short)
  TEXTAREA // Long text input (Discord TextInputStyle.Paragraph)
}

// User Answers to Onboarding Questions
model OnboardingAnswer {
  id         String   @id @default(uuid())
  userId     Int      @db.UnsignedInt
  questionId String
  answer     String   @db.Text
  discordId  String
  answeredAt DateTime @default(now()) @db.DateTime(0)

  user     User               @relation("userOnboardingAnswers", fields: [userId], references: [id])
  question OnboardingQuestion @relation(fields: [questionId], references: [id])

  @@unique([userId, questionId])
  @@index([discordId])
  @@index([userId])
}

// Onboarding Sessions (Track onboarding progress)
model OnboardingSession {
  id                 String    @id @default(uuid())
  discordId          String    @unique
  discordUsername    String
  tosAccepted        Boolean   @default(false)
  questionsCompleted Boolean   @default(false)
  roleAssigned       Boolean   @default(false)
  registeredInDb     Boolean   @default(false)
  startedAt          DateTime  @default(now()) @db.DateTime(0)
  completedAt        DateTime?

  @@index([discordId])
  @@index([tosAccepted, questionsCompleted])
}

// Discord Channel Publish Status - Track when channels were last published
enum DiscordChannelType {
  PRICING // Services/Pricing channel
  TOS // Terms of Service channel
  TICKETS // Ticket creation channels (4 channels)
  ACCOUNTS // Account shop channel
  PAYMENTS // Payment methods channel
}

model DiscordChannelPublishStatus {
  id              String             @id @default(uuid())
  channelType     DiscordChannelType @unique
  channelId       String? // Discord channel ID
  lastPublishedAt DateTime?          @db.DateTime(0)
  lastPublishedBy Int?               @db.UnsignedInt // User who triggered publish
  messageCount    Int                @default(0)
  status          String             @default("never_published") // never_published, published, needs_update, error
  lastError       String?            @db.Text
  createdAt       DateTime           @default(now()) @db.DateTime(0)
  updatedAt       DateTime           @default(now()) @updatedAt @db.DateTime(0)

  @@index([channelType])
  @@index([status])
}

model MentionTracker {
  id                    String    @id @default(uuid())
  channelId             String
  messageId             String
  messageUrl            String?
  mentionedUserId       String
  mentionedByUserId     String
  mentionedAt           DateTime  @default(now()) @db.DateTime(0)
  hasResponded          Boolean   @default(false)
  respondedAt           DateTime? @db.DateTime(0)
  channelReminderSent   Boolean   @default(false)
  channelReminderSentAt DateTime? @db.DateTime(0)
  dmReminderSent        Boolean   @default(false)
  dmReminderSentAt      DateTime? @db.DateTime(0)
  reminderDelayMinutes  Int       @default(15)
  isActive              Boolean   @default(true)

  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  @@unique([channelId, messageId, mentionedUserId])
  @@index([mentionedUserId])
  @@index([channelId])
  @@index([hasResponded])
  @@index([isActive, hasResponded, channelReminderSent])
  @@index([isActive, hasResponded, dmReminderSent])
}

// ============================================
// DAILY REWARD SYSTEM
// ============================================

// Daily Reward Configuration (Admin-managed)
model DailyRewardConfig {
  id            String   @id @default("default-config")
  minAmount     Int      @default(100)     // Minimum reward amount
  maxAmount     Int      @default(10000)   // Maximum reward amount
  cooldownHours Int      @default(24)      // Hours between claims
  isEnabled     Boolean  @default(true)    // Enable/disable feature
  currencyName  String   @default("coins") // e.g., "coins", "gold", "points"
  currencyEmoji String   @default("ðŸª™")    // Emoji for display
  gifUrl        String?  @db.Text          // GIF URL for reward message (default handled in code)
  thumbnailUrl  String?  @db.Text          // Thumbnail for embed
  createdAt     DateTime @default(now()) @db.DateTime(0)
  updatedAt     DateTime @default(now()) @updatedAt @db.DateTime(0)
}

// Daily Reward Claims (Track each claim)
model DailyRewardClaim {
  id        String   @id @default(uuid())
  userId    Int      @db.UnsignedInt
  amount    Int                          // Amount received
  claimedAt DateTime @default(now()) @db.DateTime(0)

  user User @relation("userDailyRewardClaims", fields: [userId], references: [id])

  @@index([userId])
  @@index([claimedAt])
  @@index([userId, claimedAt])
}

// Order Reward Configuration (Admin configurable)
model OrderRewardConfig {
  id               String          @id @default("default-config")
  isEnabled        Boolean         @default(false)
  rewardType       OrderRewardType @default(PERCENTAGE)
  fixedAmount      Decimal         @default(5) @db.Decimal(18, 2)      // Fixed reward amount
  percentage       Decimal         @default(2) @db.Decimal(5, 2)       // Percentage of order value
  minReward        Decimal         @default(1) @db.Decimal(18, 2)      // Min reward (for percentage)
  maxReward        Decimal         @default(50) @db.Decimal(18, 2)     // Max reward cap
  minOrderAmount   Decimal         @default(20) @db.Decimal(18, 2)     // Min order to qualify
  firstOrderBonus  Decimal         @default(0) @db.Decimal(18, 2)      // Bonus for first order
  notifyDiscord    Boolean         @default(true)                       // Send Discord notification
  currencyName     String          @default("$")
  createdAt        DateTime        @default(now()) @db.DateTime(0)
  updatedAt        DateTime        @default(now()) @updatedAt @db.DateTime(0)
}

// Order Reward Claims (Track each order reward)
model OrderRewardClaim {
  id          String   @id @default(uuid())
  orderId     String   @unique
  userId      Int      @db.UnsignedInt
  orderAmount Decimal  @db.Decimal(18, 2)  // Original order value
  rewardAmount Decimal @db.Decimal(18, 2)  // Reward given
  isFirstOrder Boolean @default(false)      // Was this their first order
  claimedAt   DateTime @default(now()) @db.DateTime(0)

  user  User  @relation("userOrderRewardClaims", fields: [userId], references: [id])
  order Order @relation("orderRewardClaim", fields: [orderId], references: [id])

  @@index([userId])
  @@index([orderId])
  @@index([claimedAt])
}

// Crypto Wallet addresses for receiving payments
model CryptoWallet {
  id               String   @id @default(uuid())
  name             String                          // "Main LTC Wallet", "BTC Payments"
  currency         String                          // LTC, BTC, ETH, USDT
  network          String                          // litecoin, bitcoin, ethereum, tron
  address          String                          // The wallet address
  upchargePercent  Float    @default(0)            // Upcharge percentage (e.g., 5 = 5%)
  isActive         Boolean  @default(true)
  createdAt        DateTime @default(now()) @db.DateTime(0)
  updatedAt        DateTime @default(now()) @updatedAt @db.DateTime(0)

  @@index([currency])
  @@index([isActive])
}

// ============================================
// MANUAL PAYMENT METHODS SYSTEM
// ============================================

enum ManualPaymentType {
  PAYPAL
  ZELLE
  WISE
  REVOLUT
  E_TRANSFER
  CASHAPP
  VENMO
  OTHER
}

// Manual Payment Options (PayPal, Zelle, Wise, etc.)
model ManualPaymentOption {
  id              String            @id @default(uuid())
  name            String                              // Display name: "PayPal", "Zelle"
  type            ManualPaymentType                   // Type enum
  icon            String?           @default("ðŸ’³")   // Emoji icon

  // Dynamic details stored as JSON
  // PayPal: { email, paypalMe }
  // Zelle: { email, phone, bankName }
  // Wise: { email, accountHolder }
  // Revolut: { username, phone }
  // E-Transfer: { email, securityQuestion, securityAnswer }
  // CashApp: { cashtag }
  // Venmo: { username }
  // Other: { customLabel, customValue }
  details         Json

  // Instructions shown to customer
  instructions    String?           @db.Text

  upchargePercent Float             @default(0)      // Upcharge percentage (e.g., 5 = 5%)
  isActive        Boolean           @default(true)
  sortOrder       Int               @default(0)

  createdAt       DateTime          @default(now()) @db.DateTime(0)
  updatedAt       DateTime          @default(now()) @updatedAt @db.DateTime(0)

  @@index([type])
  @@index([isActive])
  @@index([sortOrder])
}

// Discord Payment Message Configuration
model PaymentDiscordConfig {
  id                  String   @id @default("default")

  // Embed content
  title               String   @default("ðŸ’³ Payment Methods")
  description         String?  @db.Text
  color               String   @default("5865F2")  // Hex without #
  bannerUrl           String?  @db.Text            // Large image at bottom (like TOS)
  thumbnailUrl        String?  @db.Text            // Small image on right

  // Button configurations
  cryptoButtonLabel   String   @default("ðŸ”— Cryptocurrency")
  cryptoButtonStyle   String   @default("PRIMARY")  // PRIMARY, SECONDARY, SUCCESS, DANGER
  paymentButtonLabel  String   @default("ðŸ’µ Other Payments")
  paymentButtonStyle  String   @default("SECONDARY")

  footerText          String?  @db.Text

  updatedAt           DateTime @default(now()) @updatedAt @db.DateTime(0)
}

// Account Data Collection for Orders
model AccountTypeTemplate {
  id        String   @id @default(uuid())
  name      String   @unique
  slug      String   @unique
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)
  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  questions AccountQuestion[]
}

model AccountQuestion {
  id          String  @id @default(uuid())
  templateId  String
  fieldName   String
  label       String
  placeholder String?
  isRequired  Boolean @default(true)
  sortOrder   Int     @default(0)

  template AccountTypeTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId])
}

model OrderAccountData {
  id            String   @id @default(uuid())
  orderId       String   @unique
  accountType   String
  encryptedData String   @db.Text
  submittedAt   DateTime @default(now()) @db.DateTime(0)
  submittedBy   String

  isClaimed     Boolean   @default(false)
  claimedAt     DateTime? @db.DateTime(0)
  claimedBy     String?
  claimedByRole String?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
}
