generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  admin
  system
  tester
  user
}

enum DiscordRole {
  admin
  support
  worker
  customer
}

enum OtpType {
  verify_email
  forget_email
}

model User {
  id                  Int       @id @default(autoincrement()) @db.UnsignedInt
  fullname            String
  username            String?   @unique
  email               String    @unique
  phone               String?
  password            String?
  profileId           Int?      @unique @db.UnsignedInt
  emailIsVerified     Boolean   @default(false)
  emailVerifyToken    String?
  passwordSetupToken  String?   @unique
  passwordSetupExpiry DateTime? @db.DateTime(0)
  banned              Boolean   @default(false)
  role                Role      @default(user)
  createdAt           DateTime  @default(now()) @db.DateTime(0)
  updatedAt           DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt           DateTime?

  // Discord integration
  discordId          String?      @unique // Discord user ID (e.g., "1135250199338549299")
  discordUsername    String? // Discord username (e.g., "monasser.eng_09706")
  discordDisplayName String? // Discord display name / global name (e.g., "Mohamed Nasser")
  discordRole        DiscordRole? @default(customer) // Discord server role

  sessions    Session[]
  otpRequests OtpRequest[]
  files       File[]       @relation("fileUploader")
  profile     File?        @relation("userProfile", fields: [profileId], references: [id])

  // Order relations
  customerOrders      Order[]              @relation("customerOrders")
  workerOrders        Order[]              @relation("workerOrders")
  supportOrders       Order[]              @relation("supportOrders")
  statusChangeHistory OrderStatusHistory[] @relation("statusChangeHistory")

  transactions              Transaction[]       @relation("userTransactions")
  wallet                    Wallet?             @relation("userWallet")
  walletTransactionsCreated WalletTransaction[] @relation("transactionCreator")

  // Ticket relations
  customerTickets Ticket[]        @relation("customerTickets")
  supportTickets  Ticket[]        @relation("supportTickets")
  ticketMessages  TicketMessage[] @relation("ticketMessageAuthor")

  // Onboarding relations
  tosAcceptances    TosAcceptance[]    @relation("userTosAcceptances")
  onboardingAnswers OnboardingAnswer[] @relation("userOnboardingAnswers")

  // Issue relations
  reportedIssues OrderIssue[] @relation("reportedIssues")
  resolvedIssues OrderIssue[] @relation("resolvedIssues")

  @@index([email])
  @@index([role])
  @@index([discordId])
  @@index([discordRole])
}

model Session {
  id            Int       @id @default(autoincrement()) @db.UnsignedInt
  token         String    @unique
  identifier    String
  userId        Int       @db.UnsignedInt
  tenantId      String?
  companyId     Int?      @db.UnsignedInt
  source        String?
  langCode      String?
  expired       Boolean   @default(false)
  expired_since DateTime? @db.DateTime(0)
  createdAt     DateTime  @default(now()) @db.DateTime(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tenantId])
  @@index([companyId])
}

model OtpRequest {
  id        String   @id @default(uuid())
  userId    Int?     @db.UnsignedInt
  email     String?
  otp       String
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  expiredAt DateTime @default(now()) @db.DateTime(0)
  createdAt DateTime @default(now()) @db.DateTime(0)
  type      OtpType

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
}

model File {
  id         Int      @id @default(autoincrement()) @db.UnsignedInt
  title      String
  folder     String
  size       Int
  format     String
  uploadedBy Int      @db.UnsignedInt
  createdAt  DateTime @default(now()) @db.DateTime(0)

  uploader          User              @relation("fileUploader", fields: [uploadedBy], references: [id], onDelete: Cascade)
  user              User?             @relation("userProfile")
  serviceCategories ServiceCategory[] @relation("categoryIcon")
}

enum PricingUnit {
  FIXED
  PER_LEVEL
  PER_KILL
  PER_ITEM
  PER_HOUR
}

enum ModifierType {
  PERCENTAGE // +10%, +20%, etc.
  FIXED // +50M, -10M, etc.
}

enum ModifierDisplayType {
  NORMAL // Standard modifier display
  UPCHARGE // Highlighted as upcharge (red)
  DISCOUNT // Highlighted as discount (green)
  NOTE // Highlighted as note (green)
  WARNING // Highlighted as warning (yellow)
}

enum PaymentType {
  CRYPTO // Bitcoin, ETH, etc.
  NON_CRYPTO // PayPal, Bank, etc.
}

enum AccountStatus {
  AVAILABLE // Ready to use
  RESERVED // Reserved for order
  IN_USE // Currently being used
  COMPLETED // Service completed
}

enum OrderStatus {
  PENDING // Created, awaiting assignment
  CLAIMING // Posted to job claiming channel
  ASSIGNED // Worker assigned
  IN_PROGRESS // Worker actively working
  AWAITING_CONFIRM // Worker marked complete
  COMPLETED // Customer confirmed
  CANCELLED // Order cancelled
  DISPUTED // Issue reported
  REFUNDED // Refund issued
}

enum TicketType {
  PURCHASE_SERVICES_OSRS // Buy OSRS services (Sailing, Agility, etc.)
  PURCHASE_SERVICES_RS3 // Buy RS3 services
  BUY_GOLD_OSRS // Purchase OSRS gold
  BUY_GOLD_RS3 // Purchase RS3 gold
  SELL_GOLD_OSRS // Sell OSRS gold to us
  SELL_GOLD_RS3 // Sell RS3 gold to us
  SWAP_CRYPTO // Swap cryptocurrency
  GENERAL // General support ticket
}

enum TicketStatus {
  OPEN // Just created, waiting for support
  IN_PROGRESS // Order created, work ongoing
  AWAITING_CONFIRMATION // Worker marked complete
  COMPLETED // Customer confirmed, payouts done
  CANCELLED // Order cancelled
  CLOSED // Ticket closed without order
}

enum TransactionType {
  DEPOSIT // User adds money
  WITHDRAWAL // User withdraws money
  PAYMENT // User pays for service
  REFUND // Refund issued
}

model ServiceCategory {
  id           String    @id @default(uuid())
  name         String
  slug         String    @unique
  emoji        String?
  description  String?   @db.Text
  iconId       Int?      @db.UnsignedInt
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  icon File? @relation("categoryIcon", fields: [iconId], references: [id])

  services Service[] @relation("serviceCategory")
  accounts Account[] @relation("accountCategory")

  tickets        Ticket[]                @relation("categoryTickets")
  ticketSettings CategoryTicketSettings? @relation("categoryTicketSettings")

  @@index([slug])
  @@index([active])
  @@index([displayOrder])
}

model Service {
  id           String    @id @default(uuid())
  categoryId   String
  name         String
  slug         String
  description  String?   @db.Text
  emoji        String?
  imageUrl     String? // OSRS Wiki image URL for service icon
  active       Boolean   @default(true)
  displayOrder Int       @default(0)
  createdAt    DateTime  @default(now()) @db.DateTime(0)
  updatedAt    DateTime  @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  category         ServiceCategory   @relation("serviceCategory", fields: [categoryId], references: [id])
  serviceModifiers ServiceModifier[] @relation("serviceModifiers")
  pricingMethods   PricingMethod[]   @relation("servicePricingMethods")
  accounts         Account[]         @relation("accountService")
  orders           Order[]           @relation("serviceOrders")
  tickets          Ticket[]          @relation("serviceTickets")

  @@unique([categoryId, slug])
  @@index([categoryId])
  @@index([active])
  @@index([displayOrder])
}

model ServiceModifier {
  id           String              @id @default(uuid())
  serviceId    String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  displayType  ModifierDisplayType @default(NORMAL)
  priority     Int                 @default(0)
  condition    String?             @db.Text
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  service Service @relation("serviceModifiers", fields: [serviceId], references: [id])

  @@index([serviceId])
  @@index([priority])
  @@index([active])
}

model PricingMethod {
  id           String      @id @default(uuid())
  serviceId    String
  name         String
  groupName    String? // Group name for organizing methods (e.g., "ARMA - Armadyl", "BANDOS - Bandos")
  description  String?     @db.Text
  basePrice    Decimal     @db.Decimal(18, 8)
  pricingUnit  PricingUnit @default(FIXED)
  startLevel   Int? // Starting level for level-based pricing (e.g., 1, 40, 50)
  endLevel     Int? // Ending level for level-based pricing (e.g., 40, 50, 99)
  displayOrder Int         @default(0)
  active       Boolean     @default(true)
  createdAt    DateTime    @default(now()) @db.DateTime(0)
  updatedAt    DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt    DateTime?

  service      Service           @relation("servicePricingMethods", fields: [serviceId], references: [id])
  modifiers    PricingModifier[] @relation("pricingMethodModifiers")
  methodPrices MethodPrice[]     @relation("pricingMethodPrices")
  orders       Order[]           @relation("pricingMethodOrders")

  @@index([serviceId])
  @@index([active])
  @@index([displayOrder])
  @@index([startLevel, endLevel])
  @@index([groupName])
}

model PricingModifier {
  id           String              @id @default(uuid())
  methodId     String
  name         String
  modifierType ModifierType
  value        Decimal             @db.Decimal(10, 2)
  condition    String?             @db.Text // JSON string for complex conditions
  displayType  ModifierDisplayType @default(NORMAL) // How to display this modifier
  priority     Int                 @default(0)
  active       Boolean             @default(true)
  createdAt    DateTime            @default(now()) @db.DateTime(0)
  updatedAt    DateTime            @default(now()) @updatedAt() @db.DateTime(0)

  method PricingMethod @relation("pricingMethodModifiers", fields: [methodId], references: [id])

  @@index([methodId])
  @@index([priority])
  @@index([active])
}

model PaymentMethod {
  id        String      @id @default(uuid())
  name      String
  type      PaymentType
  active    Boolean     @default(true)
  createdAt DateTime    @default(now()) @db.DateTime(0)
  updatedAt DateTime    @default(now()) @updatedAt() @db.DateTime(0)
  deletedAt DateTime?

  methodPrices       MethodPrice[]       @relation("paymentMethodPrices")
  orders             Order[]             @relation("paymentMethodOrders")
  tickets            Ticket[]            @relation("paymentMethodTickets")
  walletTransactions WalletTransaction[] @relation("transactionPaymentMethod")

  @@index([type])
  @@index([active])
}

model MethodPrice {
  id              String   @id @default(uuid())
  methodId        String
  paymentMethodId String
  price           Decimal  @db.Decimal(10, 2)
  createdAt       DateTime @default(now()) @db.DateTime(0)
  updatedAt       DateTime @default(now()) @updatedAt() @db.DateTime(0)

  method        PricingMethod @relation("pricingMethodPrices", fields: [methodId], references: [id])
  paymentMethod PaymentMethod @relation("paymentMethodPrices", fields: [paymentMethodId], references: [id])

  @@unique([methodId, paymentMethodId])
  @@index([methodId])
  @@index([paymentMethodId])
}

// Future Models (Schema only - not implemented in this sprint)
model Account {
  id          String        @id @default(uuid())
  categoryId  String
  serviceId   String
  accountData Json // Encrypted account credentials
  status      AccountStatus @default(AVAILABLE)
  reservedAt  DateTime?
  completedAt DateTime?
  createdAt   DateTime      @default(now()) @db.DateTime(0)
  updatedAt   DateTime      @default(now()) @updatedAt() @db.DateTime(0)

  category ServiceCategory @relation("accountCategory", fields: [categoryId], references: [id])
  service  Service         @relation("accountService", fields: [serviceId], references: [id])
  orders   Order[]         @relation("accountOrders")

  @@index([categoryId])
  @@index([serviceId])
  @@index([status])
}

model Order {
  id          String @id @default(uuid())
  orderNumber Int    @unique @default(0)

  customerId Int  @db.UnsignedInt
  workerId   Int? @db.UnsignedInt // Null if unassigned
  supportId  Int? @db.UnsignedInt // Support who created order

  // Links
  ticketId        String?
  serviceId       String?
  methodId        String?
  paymentMethodId String?
  accountId       String?

  // Discord
  orderChannelId  String? @unique // Order channel ID
  claimMessageId  String? // Message in job claiming channel
  pinnedMessageId String? // Main pinned status message in ticket channel
  ticketChannelId String? // Ticket channel ID (for quick access)

  // Financials
  orderValue    Decimal @db.Decimal(18, 8)
  depositAmount Decimal @db.Decimal(18, 8)
  currency      String  @default("USD")

  // Payout tracking
  workerPayout    Decimal? @db.Decimal(18, 8) // 80%
  supportPayout   Decimal? @db.Decimal(18, 8) // 5%
  systemPayout    Decimal? @db.Decimal(18, 8) // 15%
  payoutProcessed Boolean  @default(false) // Idempotency flag to prevent duplicate payouts

  // Status
  status OrderStatus @default(PENDING)

  // Job details (for worker)
  jobDetails Json?

  // Notes
  completionNotes    String? @db.Text
  cancellationReason String? @db.Text

  // Customer feedback
  rating     Int? // 1-5 stars
  review     String?   @db.Text
  reviewedAt DateTime? @db.DateTime(0)

  // Timestamps
  createdAt   DateTime  @default(now()) @db.DateTime(0)
  updatedAt   DateTime  @default(now()) @updatedAt @db.DateTime(0)
  assignedAt  DateTime?
  claimedAt   DateTime?
  startedAt   DateTime?
  completedAt DateTime?
  confirmedAt DateTime?
  cancelledAt DateTime?

  // Optimistic locking - prevents race conditions
  version Int @default(0)

  // Relations
  customer           User                 @relation("customerOrders", fields: [customerId], references: [id])
  worker             User?                @relation("workerOrders", fields: [workerId], references: [id])
  support            User?                @relation("supportOrders", fields: [supportId], references: [id])
  ticket             Ticket?              @relation("ticketOrders", fields: [ticketId], references: [id])
  service            Service?             @relation("serviceOrders", fields: [serviceId], references: [id])
  method             PricingMethod?       @relation("pricingMethodOrders", fields: [methodId], references: [id])
  paymentMethod      PaymentMethod?       @relation("paymentMethodOrders", fields: [paymentMethodId], references: [id])
  account            Account?             @relation("accountOrders", fields: [accountId], references: [id])
  legacyTransactions Transaction[]        @relation("orderTransactions")
  walletTransactions WalletTransaction[]  @relation("orderWalletTransactions")
  statusHistory      OrderStatusHistory[]
  issues             OrderIssue[]

  @@index([customerId])
  @@index([workerId])
  @@index([status])
  @@index([ticketId])
  @@index([createdAt])
  @@index([workerId, status]) // Composite index for worker's orders filtered by status
  @@index([customerId, status]) // Composite index for customer's orders filtered by status
}

model OrderStatusHistory {
  id          String       @id @default(uuid())
  orderId     String
  fromStatus  OrderStatus?
  toStatus    OrderStatus
  changedById Int          @db.UnsignedInt
  reason      String?      @db.Text
  createdAt   DateTime     @default(now()) @db.DateTime(0)

  order     Order @relation(fields: [orderId], references: [id])
  changedBy User  @relation("statusChangeHistory", fields: [changedById], references: [id])

  @@index([orderId])
}

enum IssueStatus {
  OPEN
  IN_REVIEW
  RESOLVED
  CLOSED
}

enum IssuePriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model OrderIssue {
  id               String        @id @default(uuid())
  orderId          String
  reportedById     Int           @db.UnsignedInt
  issueDescription String        @db.Text
  status           IssueStatus   @default(OPEN)
  priority         IssuePriority @default(MEDIUM)
  resolution       String?       @db.Text
  resolvedById     Int?          @db.UnsignedInt
  discordMessageId String?
  discordChannelId String?
  createdAt        DateTime      @default(now()) @db.DateTime(0)
  updatedAt        DateTime      @default(now()) @updatedAt @db.DateTime(0)
  resolvedAt       DateTime?     @db.DateTime(0)

  order      Order @relation(fields: [orderId], references: [id])
  reportedBy User  @relation("reportedIssues", fields: [reportedById], references: [id])
  resolvedBy User? @relation("resolvedIssues", fields: [resolvedById], references: [id])

  @@index([orderId])
  @@index([reportedById])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
}

model Transaction {
  id        String          @id @default(uuid())
  userId    Int             @db.UnsignedInt
  orderId   String?
  type      TransactionType
  amount    Decimal         @db.Decimal(10, 2)
  currency  String          @default("USD")
  status    String          @default("PENDING")
  createdAt DateTime        @default(now()) @db.DateTime(0)

  user  User   @relation("userTransactions", fields: [userId], references: [id])
  order Order? @relation("orderTransactions", fields: [orderId], references: [id])

  @@index([userId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

// Wallet Types
enum WalletType {
  CUSTOMER
  WORKER
  SUPPORT
}

// Wallet Transaction Types
enum WalletTransactionType {
  DEPOSIT // Customer adds funds
  WITHDRAWAL // User withdraws funds
  PAYMENT // Payment for order (locks funds)
  REFUND // Order refunded
  EARNING // Worker payout (80%)
  COMMISSION // Support commission (5%)
  SYSTEM_FEE // System takes cut (15%)
  ADJUSTMENT // Manual correction
  RELEASE // Release locked funds after order complete
  WORKER_DEPOSIT // Worker security deposit payment
}

// Wallet Transaction Status
enum WalletTransactionStatus {
  PENDING
  COMPLETED
  FAILED
  REVERSED
}

model Wallet {
  id             String     @id @default(uuid())
  userId         Int        @unique @db.UnsignedInt
  walletType     WalletType @default(CUSTOMER)
  balance        Decimal    @default(0) @db.Decimal(18, 8)
  pendingBalance Decimal    @default(0) @db.Decimal(18, 8) // Locked for orders
  deposit        Decimal    @default(0) @db.Decimal(18, 8) // Worker security deposit
  currency       String     @default("USD")
  isActive       Boolean    @default(true)
  createdAt      DateTime   @default(now()) @db.DateTime(0)
  updatedAt      DateTime   @default(now()) @updatedAt() @db.DateTime(0)

  user         User                @relation("userWallet", fields: [userId], references: [id])
  transactions WalletTransaction[]

  @@index([userId])
  @@index([walletType])
}

model WalletTransaction {
  id            String                  @id @default(uuid())
  walletId      String
  orderId       String?
  type          WalletTransactionType
  amount        Decimal                 @db.Decimal(18, 8)
  balanceBefore Decimal                 @db.Decimal(18, 8)
  balanceAfter  Decimal                 @db.Decimal(18, 8)
  depositBefore Decimal?                @db.Decimal(18, 8) // For WORKER_DEPOSIT tracking
  depositAfter  Decimal?                @db.Decimal(18, 8) // For WORKER_DEPOSIT tracking
  currency      String                  @default("USD")
  status        WalletTransactionStatus @default(COMPLETED)

  // Payment details
  paymentMethodId String?
  reference       String? // External transaction ID
  notes           String? @db.Text

  // Actor who created this transaction
  createdById Int @db.UnsignedInt

  createdAt DateTime @default(now()) @db.DateTime(0)

  wallet        Wallet         @relation(fields: [walletId], references: [id])
  order         Order?         @relation("orderWalletTransactions", fields: [orderId], references: [id])
  paymentMethod PaymentMethod? @relation("transactionPaymentMethod", fields: [paymentMethodId], references: [id])
  createdBy     User           @relation("transactionCreator", fields: [createdById], references: [id])

  @@index([walletId])
  @@index([orderId])
  @@index([type])
  @@index([createdAt])
}

// System Wallet (singleton for system funds)
model SystemWallet {
  id        String   @id @default("system-wallet")
  balance   Decimal  @default(0) @db.Decimal(18, 8)
  currency  String   @default("USD")
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)
}

model DiscordMessage {
  id          String    @id @default(uuid())
  messageId   String    @unique
  channelId   String
  messageType String // "CATEGORY_LIST", "SERVICE_DETAIL", "GROUPED_CATEGORIES", "TOS", "TICKET_MENU", "CALCULATOR", "HEADER"
  categoryId  String?
  serviceId   String?
  groupIndex  Int? // For grouped messages (0, 1, 2, etc.)
  isPinned    Boolean   @default(false) // Track if message is pinned
  createdAt   DateTime  @default(now()) @db.DateTime(0)
  updatedAt   DateTime  @default(now()) @updatedAt @db.DateTime(0) // Track last update
  expiresAt   DateTime? @db.DateTime(0)

  @@index([messageId])
  @@index([channelId])
  @@index([messageType])
}

// OSRS Experience Table (levels 1-99)
model ExperienceTable {
  level      Int    @id @db.UnsignedTinyInt // 1-99
  experience BigInt // Total XP required for this level
  difference Int // XP difference from previous level

  @@index([level])
}

// ============================================
// TICKET SYSTEM MODELS
// ============================================

model Ticket {
  id           String @id @default(uuid())
  ticketNumber Int    @unique @default(autoincrement())

  // Ticket Type (NEW)
  ticketType TicketType @default(GENERAL)

  // Customer who opened the ticket
  customerId        Int    @db.UnsignedInt
  customerDiscordId String // Discord user ID of customer

  // Category and service context
  categoryId String?
  serviceId  String?

  // Discord channel info
  channelId String @unique // Discord channel ID for this ticket

  // Pricing info from calculator (optional)
  calculatedPrice Decimal? @db.Decimal(18, 8)
  paymentMethodId String?
  currency        String   @default("USD")

  // Status tracking
  status TicketStatus @default(OPEN)

  // Support who handled the ticket
  supportId        Int?    @db.UnsignedInt
  supportDiscordId String?

  // Additional notes from customer
  customerNotes String? @db.Text

  // Timestamps
  createdAt DateTime  @default(now()) @db.DateTime(0)
  updatedAt DateTime  @default(now()) @updatedAt @db.DateTime(0)
  closedAt  DateTime? @db.DateTime(0)

  // Relations
  customer      User             @relation("customerTickets", fields: [customerId], references: [id])
  support       User?            @relation("supportTickets", fields: [supportId], references: [id])
  category      ServiceCategory? @relation("categoryTickets", fields: [categoryId], references: [id])
  service       Service?         @relation("serviceTickets", fields: [serviceId], references: [id])
  paymentMethod PaymentMethod?   @relation("paymentMethodTickets", fields: [paymentMethodId], references: [id])
  messages      TicketMessage[]
  orders        Order[]          @relation("ticketOrders")
  metadata      TicketMetadata?  @relation("ticketMetadata")

  @@index([customerId])
  @@index([categoryId])
  @@index([serviceId])
  @@index([status])
  @@index([channelId])
  @@index([ticketType])
  @@index([createdAt])
}

model TicketMessage {
  id       String @id @default(uuid())
  ticketId String

  // Message author
  authorId        Int    @db.UnsignedInt
  authorDiscordId String // Discord user ID
  authorName      String // Display name at time of message

  // Message content
  content String @db.Text

  // Message type
  isSystem  Boolean @default(false) // Auto-generated system messages
  isWelcome Boolean @default(false) // Welcome message

  // Discord message reference
  discordMessageId String? @unique

  createdAt DateTime @default(now()) @db.DateTime(0)

  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author User   @relation("ticketMessageAuthor", fields: [authorId], references: [id])

  @@index([ticketId])
  @@index([authorId])
  @@index([createdAt])
}

// Category-specific ticket welcome message settings
model CategoryTicketSettings {
  id         String @id @default(uuid())
  categoryId String @unique

  // Banner image
  bannerUrl String? @db.Text

  // Welcome message content
  welcomeTitle   String? @db.VarChar(255)
  welcomeMessage String  @db.Text // Rich text / Markdown supported

  // Footer text
  footerText String? @db.Text

  // Embed color (hex without #)
  embedColor String? @default("5865F2") @db.VarChar(6)

  // Toggle
  isActive Boolean @default(true)

  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  category ServiceCategory @relation("categoryTicketSettings", fields: [categoryId], references: [id], onDelete: Cascade)
}

// Ticket metadata for gold/crypto transactions
model TicketMetadata {
  id       String @id @default(uuid())
  ticketId String @unique

  // Gold transaction fields
  goldAmount     Decimal? @db.Decimal(15, 2) // Amount in millions (e.g., 100M)
  goldRate       Decimal? @db.Decimal(10, 4) // Rate per M (e.g., $0.45/M)
  deliveryMethod String?  @db.VarChar(100) // F2P, P2P, Drop Trading, etc.
  worldLocation  String?  @db.VarChar(200) // "W301, Grand Exchange"
  osrsUsername   String?  @db.VarChar(100) // Customer's OSRS/RS3 username

  // Crypto transaction fields
  cryptoType    String?  @db.VarChar(50) // BTC, ETH, USDT, etc.
  cryptoAmount  Decimal? @db.Decimal(20, 8) // Crypto amount
  walletAddress String?  @db.VarChar(500) // Customer's wallet address
  swapDirection String?  @db.VarChar(50) // CRYPTO_TO_GOLD or GOLD_TO_CRYPTO

  // Payment details (for sell gold)
  paymentEmail String?  @db.VarChar(255) // PayPal email or similar
  paymentProof String?  @db.Text // URL to payment proof
  payoutAmount Decimal? @db.Decimal(18, 8) // Amount paid to customer

  // Additional notes
  specialNotes  String? @db.Text
  internalNotes String? @db.Text // Staff-only notes

  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  ticket Ticket @relation("ticketMetadata", fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId])
}

// Ticket Type Settings - Customization per ticket type
model TicketTypeSettings {
  id         String     @id @default(uuid())
  ticketType TicketType @unique

  // Grouping (for types that share welcome messages)
  groupKey     String? @db.VarChar(50)
  buttonLabel  String? @db.VarChar(100)
  buttonColor  String? @db.VarChar(20) // "green", "blue", "red", "gray"
  displayOrder Int     @default(0)

  // Welcome message customization (shared across group if groupKey is set)
  bannerUrl      String? @db.Text
  thumbnailUrl   String? @db.Text
  welcomeTitle   String? @db.VarChar(255)
  welcomeMessage String  @db.Text
  footerText     String? @db.Text
  embedColor     String? @default("5865F2") @db.VarChar(6)

  // Dynamic form fields (JSON array) - unique per type
  // Each field: { id, label, type, required, placeholder, options[], min, max }
  customFields Json?

  // Auto-assignment settings
  autoAssign Boolean @default(false)

  // Notification settings
  notifyOnCreate  Boolean @default(true)
  notifyOnClose   Boolean @default(true)
  mentionSupport  Boolean @default(true)
  mentionCustomer Boolean @default(true)

  // Active toggle (per type - can disable RS3 but keep OSRS active)
  isActive Boolean @default(true)

  createdAt DateTime @default(now()) @db.DateTime(0)
  updatedAt DateTime @default(now()) @updatedAt @db.DateTime(0)

  @@index([ticketType])
  @@index([isActive])
  @@index([groupKey])
}

// ============================================
// ONBOARDING SYSTEM
// ============================================

// Terms of Service Content
model TermsOfService {
  id           String   @id @default(uuid())
  title        String   @db.VarChar(255)
  content      String   @db.Text // Main TOS text content
  bannerUrl    String?  @db.Text // GIF/Image URL for banner
  thumbnailUrl String?  @db.Text // Thumbnail image
  embedColor   String   @default("5865F2") @db.VarChar(6) // Hex color without #
  footerText   String?  @db.Text
  buttonLabel  String   @default("Accept Terms") @db.VarChar(100)
  isActive     Boolean  @default(true)
  version      Int      @default(1) // Track TOS versions
  createdAt    DateTime @default(now()) @db.DateTime(0)
  updatedAt    DateTime @default(now()) @updatedAt @db.DateTime(0)

  acceptances TosAcceptance[]

  @@index([isActive])
  @@index([version])
}

// User TOS Acceptances
model TosAcceptance {
  id              String   @id @default(uuid())
  userId          Int      @db.UnsignedInt
  tosId           String
  discordId       String // Discord user ID
  discordUsername String
  acceptedAt      DateTime @default(now()) @db.DateTime(0)
  ipAddress       String?  @db.VarChar(45) // Optional: track IP

  user User           @relation("userTosAcceptances", fields: [userId], references: [id])
  tos  TermsOfService @relation(fields: [tosId], references: [id])

  @@unique([userId, tosId])
  @@index([discordId])
  @@index([acceptedAt])
}

// Onboarding Questions (Admin-managed) - Only TEXT and TEXTAREA supported
model OnboardingQuestion {
  id           String            @id @default(uuid())
  question     String            @db.Text
  fieldType    QuestionFieldType @default(TEXT)
  placeholder  String?           @db.VarChar(255)
  required     Boolean           @default(true)
  minLength    Int? // For text validation
  maxLength    Int? // For text validation
  displayOrder Int               @default(0)
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now()) @db.DateTime(0)
  updatedAt    DateTime          @default(now()) @updatedAt @db.DateTime(0)

  answers OnboardingAnswer[]

  @@index([displayOrder])
  @@index([isActive])
}

enum QuestionFieldType {
  TEXT // Short text input (Discord TextInputStyle.Short)
  TEXTAREA // Long text input (Discord TextInputStyle.Paragraph)
}

// User Answers to Onboarding Questions
model OnboardingAnswer {
  id         String   @id @default(uuid())
  userId     Int      @db.UnsignedInt
  questionId String
  answer     String   @db.Text
  discordId  String
  answeredAt DateTime @default(now()) @db.DateTime(0)

  user     User               @relation("userOnboardingAnswers", fields: [userId], references: [id])
  question OnboardingQuestion @relation(fields: [questionId], references: [id])

  @@unique([userId, questionId])
  @@index([discordId])
  @@index([userId])
}

// Onboarding Sessions (Track onboarding progress)
model OnboardingSession {
  id                 String    @id @default(uuid())
  discordId          String    @unique
  discordUsername    String
  tosAccepted        Boolean   @default(false)
  questionsCompleted Boolean   @default(false)
  roleAssigned       Boolean   @default(false)
  registeredInDb     Boolean   @default(false)
  startedAt          DateTime  @default(now()) @db.DateTime(0)
  completedAt        DateTime?

  @@index([discordId])
  @@index([tosAccepted, questionsCompleted])
}
